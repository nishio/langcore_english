# Chapter 1 How to Learn a Language Efficiently

Have you ever felt you understood a concept but not quite ggot ith while studying
computer programming? If youfve had that feeling before, it was because the newly
acquired knowledge was not associated with what youfd already experienced or knew.
You also might have felt that there were simply so many things to learn that you cannot
make a proper judgement on what needs to be learned. It would be great if we could
recognize what we need to learn and what we can safely ignore.
But how would that be possible?

## 1.1 Learning by comparison

Suppose you are leaning a programming language gXh and wondering what you
need to learn and what you donft. In this case, leaning about another programming
language gYh can sometimes give you an insight on the question. That is, studying
different languages allows you to recognize things that exist in common between
these languages (gXh and gYh in this example) and also things that are unique to a
particular language.

Here, things that are common are the important topics that you need to learn and,
once you master those topics, learning another programming language gZh becomes
easier.

### Different Rules for Each Language

Learning several languages will help you understand an important fact, which is
that each language has different rules upon which it operates.
You might see textbooks on computer programming explaining different
programming rules, but that doesnft mean that those rules are universally
adopted. Rather, it just means that, for the time being, those rules turn out to be
convenient for these particular situations and they are used as the governing rules
for that specific language, for the time being[^fn1]. In other words, these textbooks
simply are simply describing some specific rules for some particular programming
languages. 

[^fn1]: The famous phraseu‚±‚¤‘‚¯‚½‚Ù‚¤‚ª©‘R‚¾‚©‚çA‚»‚¤‘‚¯‚é‚Æ‚¢‚¤–ñ‘©‚É‚µ‚æ‚¤ (–ñ‘©‚È‚ñ‚Ä‚¢
    ‚Â‚Å‚à‚Å‚«‚é I )v (gThis reads naturally so letfs agree that this is a rule that has to be followed
    (we can make a promise anytime!)) appears in the page 60 of w‰‚ß‚Ä‚Ìl‚Ì‚½‚ß‚ÌLISP[‘•â
    ‰ü’ù”Å]xihLISP for Beginnersh, Ikuo Takeuchi, Shoeisha, 2010j .

### Truthiness in C and Ruby

Letfs look at the notion of truthiness as an example. gTruthinessh here simply
refers to a rule that decides what is gtrueh (gfalseh). If youfve learned C before, you
may know that 0 resolves to gfalseh and anything other than 0 is gtrueh. Now, if C is
the only programming language youfve ever learned, you might generalize this fact
and think that a programing language in general considers 0 as gfalseh and other
values as gtrueh. However, you might be surprised to learn that, in Ruby, 0 is
regarded as gtrueh.


{title="Displays 'false!' since 0 is false in C", lang=c}
~~~~~~~
#include <stdio.h>
int main(){
  if(0){
    printf("true!\n");
  }else{
    printf("false!\n");
  }
}
~~~~~~~

{title="Displays 'true!' since 0 is true in Ruby", lang=ruby}
~~~~~~~
if 0 then
  print "true!"
else
  print"false!"
end
~~~~~~~

These gsurprisesh allow you to correct wrong assumptions you might have. In this
example, your initial assumption that g0 is generally the only value that is efalsef and any
other values are considered to be etruefh turns into one that says gC thinks 0 is efalsef
and other values are etruef whereas, in Ruby, false and nil are regarded as efalsef and
other values (expressions), the value e0f included, are etruef.

### Truthiness in Java

As I mentioned above, Ifve decided to study different programming languages in
order to understand how gtruthinessh is determined in each language. Ifd like to
share with you what Ifve discovered during this process and, in particular, how Java
treats the notion of truthiness. In Java, there is the idea of gtypeh, and there exists
a gtypeh for Boolean values (i.e. gtrueh and gfalseh). For this reason, we are not
allowed to put set 0 in a conditional because it is of type Integer and not a Boolean
type value; doing so will result in a compilation error.

Therefore, we can see that the value 0 can be treated as gtrueh, gfalseh, or even
gneither true nor falseh , depending on the language used to evaluate the value[^fn2].

[^fn2]: Letfs look at values other than numbers. In Python, not only is the value 0 is considered to be gfalseh
    but a container with the size of 0 is also defined to be gfalseh. This means that an empty string and
    an empty list are also gfalseh. In C, we use char* to deal with strings but it doesnft resolve to gfalseh
    even when char* points to an empty string. It becomes gfalseh only when it points to nothing (i.e.
    its value is NULL).

## 1.2 Learning about the History

### Understand the Intention of the Languagefs Designer

Letfs say you are leaning about the specific feature of a programming language and
not quite sure youfve actually understood the concept.

I would argue that the reason you feel a bit uncertain about your understanding of the
topic is because you are not clear on why that specific feature is needed in the first place.

Programming languages are designed by humans, which means that there were
problems that the languagefs designer wanted to solve with the new language.
Understanding the context in which the language has been developed will help you
understand the reason behind particular implementations of the language.

### What Programming Language to Learn? Nobody knows!

### Learning about Common, Language Agnostic Things

## 1.3 Summary
